 # Java并发之锁的升级

> 这是一篇主要基于《深入理解Java虚拟机》的第五部分的第13章的13.3小节的简要笔记。:dog:



> CAS小知识点。 `CompareAndSwap`， 乐观锁实现，比较并交换，为了避免ABA问题，引入了`版本`来解决。

## 自旋锁与自适应自选

### 自旋锁

`自旋锁`是用于对于占用锁的时间并不会太长的应用，将需要获得锁的线程执行一个忙循环，通过`短暂`消耗处理器资源来避免需要进去内核态挂起和恢复线程的操作。



`自旋锁`其实在代码实现层面也并不是一个陌生的东西。

跟过一些源码的话，我们经常可以看到的一段代码就常常是自旋的实现。

```java
for(;;){
    ...
}
```



### 自适应自旋

自适应自旋在`JDK`中也进行了优化，在`JDK1.6`后就默认开启并且是自适应自旋了。

自适应指的是自旋的次数是不固定的，会根据前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。

虚拟机会根据上一次执行的结果来判断是否可以自旋稍长的时间来等待锁的释放或者省略掉自旋过程进入阻塞。

---



## 锁消除与锁粗化

`锁消除`和`锁粗化`是针对于在编译器上运行时，对加锁的部分进行分析是否需要进行加锁和对加锁的范围进行扩大避免小粒度频繁互斥同步带来的消耗。



## 锁优化与升级

> 基于`HotSpot`的对象头和对象的内存布局此处决定残忍得省略，只需要记录会把对象头的标志位改变，并把锁的线程ID记录在`Mark Word`之中。:dog:

这是`JVM`对于`synchronized 运行机制` 优化的不懈努力。:rocket:



## 偏向锁

`偏向锁`的目的是为了消除数据在`无竞争`（指的是一些应用在加锁环境下多数情况其实下并不太会有竞争出现的情况）情况下对锁操作的性能开销。

`偏向锁`会偏向于第一个获得它的线程，如果在接下来执行的过程中，该锁没有被其他线程获取，那持有偏向锁的对象除了在第一次需要头部同步（使用`CAS`）之外，永远不需要再进行同步。

同样的，如果在无竞争的情况下此处被另外一个线程通过`CAS`置换后，偏向锁就变心了:cat:。

### 轻量级锁

但是，很不幸，还是会有了竞争。:dog:

当有对象A对持有偏向锁的对象B产生的竞争，这时候会去检测当前对象持有锁的对象是否已经执行完毕可以释放锁了，如果可以，那就变心。如果没有，那就进行锁的升级。

升级的过程是：

- 当前持有偏向锁的对象A执行到`安全点`后释放锁
- 锁升级为轻量级锁，把锁交给对象A继续执行
- 对象A执行完毕后通过`CAS`将锁换给线程B持有。



### 重量级锁

当有两个以上的线程争用同一个锁的时候，轻量级锁就`膨胀`为重量级锁。

从现在开始以及后面等待锁的线程都会进入阻塞状态。