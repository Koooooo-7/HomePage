# JVM小梳理

`JVM`在`JDK`的升级中也是在不断进化，比如`永久代`到后来的`元空间`。

不同版本的`JVM`看了之后是一头大雾，还有一些不同分区不同代的占比也是头大。

还是拿自己目前觉得有必要梳理记下来的东西汇总一下。:dog:

---

## 栈

栈的数据结构，压栈出栈也不用多说。

基本数据类型存在栈帧内，对象是存在堆区，栈帧内是引用。

> `StackOverflowError`感觉是递归没秀起来的常规操作23333。

## 堆

堆内存是` JVM` 所有线程共享的部分，在虚拟机启动的时候就已经创建，这也就是说的要优化的部分。

> 开局一张图，剩下全靠编。:gift:

![20190901-01](_media\20190901-01.png)

## 堆内存

在没有做任何自己配置的时候：

- 默认初始空间(`-Xms`)是物理内存的`1/64`。

- 默认最大空间（`-Xmx`）是物理内存的`1/4`。

>`-Xms` 堆内存初始大小，默认内存大小。
>
>`-Xmx` 堆内存最大值，默认内存大小。
>
>` -Xmn` 堆内存年轻代大小。

## 堆分区

- **新生代**

  - 伊甸区（真诗意），对象的创建和销毁都在这里。
  - 幸存者0区，伊甸园活下来的在这。
  - 幸存者1区，0区满了往这放。

- **老年代**

  - 幸存下来都没挂掉的来我这里，我都放不下，那我就`OOM(OutOfMemoryError)`。

    > 在进行每一次存活确认的时候也会有`代`的计数`+1`，这里不用说，可以想到很多类似的处理方式。
    > 比如`Kafka`、`Znode`，乐观锁用`version`实现等等。提到OOM就很容易想到线程池的恐惧:smile:。

- **元空间**

  元空间的本质和永久代类似，都是对`JVM`规范中方法区的实现。

  不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。

## GC

> `Garbage Collections`。

下面两种收集方式发生在哪，看图:up:。

- ` Minor GC`

- ` Full GC`



在年轻代的回收，因为会回收很大比例的对象，活下来的并不多，采用的是复制算法（`Copying`）。
