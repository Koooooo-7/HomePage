# JVM小梳理

`JVM`在`JDK`的升级中也是在不断进化，比如`永久代`到后来的`元空间`。

不同版本的`JVM`看了之后是一头大雾，还有一些不同分区不同代的占比也是头大。

还是拿自己目前觉得有必要梳理记下来的东西汇总一下。:dog:

---

## 栈

栈的数据结构，压栈出栈也不用多说。

基本数据类型存在栈帧内，对象是存在堆区，栈帧内是引用。

> `StackOverflowError`感觉是递归没秀起来的常规操作23333。

## 堆

堆内存是` JVM` 所有线程共享的部分，在虚拟机启动的时候就已经创建，这也就是说的要优化的部分。

> 开局一张图，剩下全靠编。:gift:

![20190901-01](_media\20190901-01.png)

## 堆内存

在没有做任何自己配置的时候：

- 默认初始空间(`-Xms`)是物理内存的`1/64`。

- 默认最大空间（`-Xmx`）是物理内存的`1/4`。

>`-Xms` 堆内存初始大小，默认内存大小。
>
>`-Xmx` 堆内存最大值，默认内存大小。
>
>` -Xmn` 堆内存年轻代大小。

## 堆分区

- **新生代**

  - 伊甸区（真诗意），对象的创建和销毁都在这里。
  - 幸存者0区，伊甸园活下来的在这。
  - 幸存者1区，0区满了往这放。

  >在幸存者区中又分为`from`区和`to`区。:cloud:

- **老年代**

  - 幸存下来都没挂掉的来我这里，我都放不下，那我就`OOM(OutOfMemoryError)`。

    > 在进行每一次存活确认的时候也会有`代`的计数`+1`，这里不用说，可以想到很多类似的处理方式。
    > 比如`Kafka`、`Znode`，乐观锁用`version`实现等等。提到OOM就很容易想到线程池的恐惧:smile:。

- **元空间**

  元空间的本质和永久代类似，都是对`JVM`规范中方法区的实现。

  不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。

## GC

> `Garbage Collections`。

下面两种收集方式发生在哪，看图:up:。

- ` Minor GC` 发生在新生代，频繁发生。将伊甸园的对象搬移到幸存者区，幸存者区老的对象会被放到老年区。也就是回收后伊甸园区就空了。
在回收中，每经历一次后年龄会+1，默认15后会被移动到老年区。

- ` Full GC` 发生在老年代（偶尔发生在新生代和元空间）



在新生代的回收，因为会回收很大比例的对象(`前提`)，活下来的并不多，采用的是复制算法（`Copying`）。
- 不会产生内存碎片。
- 浪费了一点内存空间。

老年代一般是标记清除或者是标记清除和标记整理的混合实现。
- 标记清除（`Mark-Sweep`）
  - 标记：从根集合开始扫描，对存活的对象进行标记。
  - 清除：再次扫描后清除，空间不连续会造成内存碎片。
- 标记整理（`Mark-Compact`）。
- 分代收集算法。
- 引用计数算法（淘汰中）。