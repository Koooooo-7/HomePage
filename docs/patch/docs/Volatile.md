# Volatile 

**Volatile**关键字在使用单例模式或者涉及到并发编程的时候肯定不会陌生。

> 部分内容算是对于《Java并发编程的艺术》第三章的读书笔记:dog:。

我们知道它有以下基本的两个特性：


- 禁止指令重排。
- 保证内存可见性（但不保证操作的原子性）。

> 禁止指令重排主要是基于插入的内存屏障实现的，具体可以看对于happens-before的讲解。


但是它具体是做了些什么呢，我们来一探究竟。

---



我们需要知道以下两点。

- JAVA每个线程都有一块属于自己的工作内存区，该内存区会保存一份从主内存**拷贝**过来的公共变量值。

- 不加volatile修饰时，每个线程中对拷贝值的修改一般都是独立的。

因为都是在自己从主内存中拷贝出来的值做彼此独立的操作，那么在多线程情况下回写入主内存时就会出现问题。

> JVM规范定义了线程对主存的操作指令：read，load，use，assign，store，write。

![](_media\20190819-01.png)

这是线程对主内存的操作流程，还有另外两个原子操作。

- lock：作用于主内存中的变量，把一个变量标识为一个线程独占的状态。
- unlock：作用于主内存中的变量，把一个处于锁定状态的变量释放出来，释放后的变量可以被其他线程锁定。

同时在执行`store`操作的时候会使用汇编指令的`lock`。

> 同时在进行加锁的过程中，也分为对总线的加锁以及对缓存的加锁。因为对于总线加锁的开销更大，所以之后是对缓存的加锁。

回到正题。

> MESI（Modified Exclusive Shared Or Invalid）（也称为伊利诺斯协议）是一种广泛使用的支持写回策略的缓存一致性协议。

`volatile`是利用了`MESI`来保证其内存可见性。就类似一种监听机制，当监听到公共变量的值发生改变后（其他线程操作改变了值），会重新去从主内存取出来公共变量更新到工作内存中再操作。

因此，当有一个线程对变量做出改变之后，其他线程能感知到改变，会去主内存重新获取并更新工作区的值，但是，改变后是否在其他线程读取时已经`及时`写回了主内存，这不一定。

也就是说，`volatile`**保证了不同内存之间公共变量的可见性，但是并不保证整个操作的原子性**，也就是说，当在多线程环境下最后的结果可能是你意料之外的。

因此在涉及并发问题的时候，你可能更多地看到的是`synchronized `，它在更大粒度上去保证了整个操作的原子性，但是也带来了一定的性能损失。