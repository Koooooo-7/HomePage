# Redis基础

## 概述

> Redis，一个用起来很快乐，面试起来可能不太快乐的玩意。:dog:
>
> 这也个算是对`《Redis 设计与实现》`的部分读书笔记吧。

`Redis`是一个通常被用来用作缓存的`K-V`存储的`NoSQL`数据库。

## 基础知识

#### 数据类型

`Redis`的数据类型一般来说有以下几种。

- `String`

  但是支持数字加减运算。（是不是很像`MySQL`）

- `List`

  同时兼具队列作用，一般是`LPUSH`和`RPOP`配合食用。:bow:

- `Set`

  存储Set集合，具有`isContain`方法快速检测。

- `ZSet(SortedSet)`

  有序Set，可以通过`Score`参数进行排序，可以做最热TopN相关的业务实现。

- `Hash`

  其实感觉应该说是一个结构体`struct`比较好。

  > 这里还有一个`hashtag`的概念，可以对相关的key（比如含有相同的前缀）的分区存储时指定`hashtag`来存在一个地方(`solt`)。

  

> 扩展部分

##### 布隆过滤器（`BloomFilter`）

布隆过滤器其实并不陌生，毕竟当初也是用`MATLAB`干过的。:dog:

布隆过滤器主要是用于判断一个元素是否在集合中。基于对数据进行hash后采样来处理，但因为hash碰撞的原因，具有一定的误判率。但是如果是判断一个元素是否不存在在集合中，这是可以保证的。

但是布隆过滤器是不支持删除元素的，因为并没有存储key，知识直接把数据映射到了数组中。

>  扩展优化的过滤器：布谷鸟过滤器。



## 业务应用

##### 分布式锁

非库直接实现，采用`SetNX`来做，执行任务完毕后直接删除。

需要注意的是要根据业务设置一定的超时过期时间，避免因为网络延迟和服务错误导致死锁，引发后面的业务也完全不可用。



##### 缓存问题

几个基础概念和解决办法。

- 缓存穿透

  概念： 被请求查询一些不存在的key，这时候因为没有缓存命中，那会打到DB上，如果是恶意的频繁请求，这样肯定是不行的。

  解决办法：

  - 暂时缓存这些没有查到的key，这样让缓存命中，返回空值或者默认设置的值。
  - 布隆过滤器作为前置缓存检查，如果缓存中没有，直接返回。

- 缓存击穿

  概念：一般来说是对热点数据（热点`key`）有大量请求访问时，缓存突然失效，这时候大量的请求打到了DB上。

  解决办法：

  - 热点数据缓存永不过期。（如果业务没有强缓存一致性问题的话。）
  - 多份缓存，即对热点数据设置不同的过期时间，有一个`缓存备份`，交替更新。
  - 缓存失效时进入数据库请求部分进行加锁，只有拿到锁的线程才能去请求数据库并生成缓存，其他线程去缓存中读取（`锁内double check`）。

- 缓存雪崩

  - 热点数据集中失效

  ​      很多key同时失效，导致缓存大面积失效，请求都打到DB上。

  解决办法：对不同的key设置不同的失效事件，在预设的失效时间上进行一定程度的散列分布，比如一组一个小时失效的，可以在设置失效时间在`1小时~1小时10分`之间。

  - 服务宕机

    服务突然宕机导致缓存不可用，请求到打到DB上。

    这样的情况涉及到的就是高可用的情。

    - 可以通过搭建集群提高可用性来解决这个问题。
    - 通过本地缓存和熔断降级进行应用保护等待故障恢复。

    


##### 缓存一致性

缓存一致性的简单解决办法就是在有数据更新时做删除缓存操作，通过对缓存生成和查库操作加锁来实现在数据更新后的缓存重新生成。



## 集群运维

> 在集群使用的场景中，除开应用本身之外需要考虑的其中一个点就是网络区域划分，不同区域的网络通信问题。

Gossip协议的主要用途就是 **信息传播和扩散** ：即把一些发生的事件传播到全世界。它们也被用于数据库复制，信息扩散，集群成员身份确认，故障探测等。

#### 主从模式

主从复制一般是用于读写分离（不得不又想到数据库的主从设计），分摊数据库的读写压力，但是**并不保证强一致性**。

主从之间的复制是通过传输`rdb`进行的，进行初次同步之后，会将操作的日志再进行同步。

#### 哨兵(`Sentinel`)模式

哨兵模式主要就是在主从模式下多了一个维持心跳检测和支持选举(raft)的过程。

#### `Cluster` 集群模式

`Redis`的集群模式是在主从模式上引入了`hash槽`来对数据进行分片实现的。

简单来说，就是一个主从模式的集群作为`hash环`的一个节点，多个主从模式的集群节点（node）分别位于`hash环`上，通过数据分片（`hash槽`），每一个节点保存一部分的数据。

节点之间的通讯使用的`Gossip`协议。

> Gossip协议的主要用途就是 **信息传播和扩散** ：即把一些发生的事件传播到全世界。它们也被用于数据库复制，信息扩散，集群成员身份确认，故障探测等。
>
> **六度分隔理论**：你和任何一个陌生人之间所间隔的人不会超过六个。



#### 备份恢复

##### RDB

##### AOF

#### 选举

### 数据分片

`Redis` 集群引入了**哈希槽slots**的概念使用数据分片（`sharding`）而非一致性哈希（`consistency hashing`）来实现。

 一个` Redis` 集群包含` 16384` 个哈希槽（`hash slot`）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式` CRC16(key) % 16384 `来计算键 key 属于哪个槽， 其中` CRC16(key)` 语句用于计算键 key 的` CRC16` 校验和 。

**hash环**

即一致性Hash算法是对`2^ 32-1`取模，每个节点(node)均匀位于环上，存储环上的一段数据。同时，还有`幻槽`（我编的词:dog:）的概念，即为了避免节点过少导致的分布不均的问题发生，可以在逻辑上虚拟出多个槽，但是实际上的存储分布在实际的物理节点上。这样可以解决`数据倾斜`的问题，减少数据分布不均。

#### 脑裂

